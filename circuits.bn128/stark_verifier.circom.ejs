pragma circom 2.1.0;

include "gl.circom";
include "poseidon.circom";
include "bitify.circom";
include "sha256/sha256.circom";
include "fft.circom";
include "merklehash.circom";
include "evalpol.circom";
include "treeselector.circom";
include "bn1togl3.circom";
include "compconstant64.circom";

<%
class Transcript {
    constructor() {
        this.state = "0";
        this.pending = [];
        this.out = [];
        this.out3 = [];
        this.stCnt =0;
        this.hCnt =0;
        this.n2bCnt =0;
        this.bn1togl3Cnt =0;

        this.code = [];
    }


    getField(v) {
        this.code.push(`${v} <== [${this.getFields1()}, ${this.getFields1()}, ${this.getFields1()}];`);    
    }

    getFields1() {
        if (this.out3.length > 0) {
            return this.out3.shift();
        }
        if (this.out.length > 0) {
            const cName = `bn1togl3_${this.bn1togl3Cnt++}`;
            this.code.push(`var ${cName}[3] = BN1toGL3()(${this.out.shift()});`);
            this.out3.push(`${cName}[0]`);
            this.out3.push(`${cName}[1]`);
            this.out3.push(`${cName}[2]`);
            return this.getFields1();
        }
        this.updateState();
        return this.getFields1();
    }

    getFields253() {
        if (this.out.length > 0) {
            return this.out.shift();
        }
        this.updateState();
        return this.getFields253();

    }

    updateState() {
        while (this.pending.length<16) {
            this.pending.push("0");
        }
        this.code.push(`var transcriptHash_${this.hCnt++}[17] = PoseidonEx(16,17)([${this.pending.join(',')}], ${this.state});`);
        for (let i=0; i<17; i++) {
            this.out[i] = `transcriptHash_${this.hCnt-1}[${i}]`;
        }
        this.out3 = [];
        this.state = `transcriptHash_${this.hCnt-1}[0]`;
        this.pending = [];
    }


    put(a, l) {
        if (typeof l !== "undefined") {
            for (let i=0; i<l; i++) {
                this._add1(`${a}[${i}]`);
            }
        } else {
            this._add1(a);
        }
    }

    _add1(a) {
        this.out = [];
        this.out3 = [];
        this.pending.push(a);
        if (this.pending.length == 16) {
            this.updateState();
        }
    }

    getPermutations(v, n, nBits) {
        const totalBits = n*nBits;
        const NFields = Math.floor((totalBits - 1)/253)+1;
        const n2b = [];
        for (let i=0; i<NFields; i++) {
            const f = this.getFields253();
            n2b[i] = `transcriptN2b_${this.n2bCnt++}`;
            this.code.push(`var ${n2b[i]}[254] = Num2Bits_strict()(${f});`);
        }
        this.code.push(`// From each transcript hash converted to bits, we assign those bits to ys[q] to define the query positions`)
        this.code.push(`var q = 0; // Query number `)
        this.code.push(`var b = 0; // Bit number `)
        for(let i = 0; i<NFields; i++) {
            const nBits = i + 1 == NFields ? totalBits - 253*i : 253;
            this.code.push(`for(var j = 0; j < ${nBits}; j++) {
        ${v}[q][b] <== ${n2b[i]}[j];
        b++;
        if(b == ${starkStruct.steps[0].nBits}) {
            b = 0; 
            q++;
        }
    }`);
        }
    }

    getCode() {
        for (let i=0; i<this.code.length; i++) this.code[i] = "    "+this.code[i];
        return this.code.join("\n");
    }

} -%>
<% function unrollCode(code) {                                                          -%>
<%
    function ref(r) {
        if (r.type == "eval") {
            return "evals[" + r.id + "]";
        } else if (r.type == "challenge") {
            return "challenges[" + r.id + "]";
        } else if (r.type == "public") {
            return "publics[" + r.id + "]";
        } else if (r.type == "x") {
            return "challenges[7]";
        } else if (r.type == "Z") {
            return "Z";
        } else if (r.type == "xDivXSubXi") {
            return "xDivXSubXi";
        } else if (r.type == "xDivXSubWXi") {
            return "xDivXSubWXi";
        } else if (r.type == "tmp") {
            return "tmp_"+r.id;
        } else if (r.type == "tree1") {
            return "mapValues.tree1_" + r.id;
        } else if (r.type == "tree2") {
            return "mapValues.tree2_" + (r.id - starkInfo.nCm1);
        } else if (r.type == "tree3") {
            return "mapValues.tree3_" + (r.id - starkInfo.nCm1 - starkInfo.nCm2);
        } else if (r.type == "tree4") {
            return "mapValues.tree4_" + (r.id - starkInfo.nCm1 - starkInfo.nCm2 - starkInfo.nCm3);
        } else if (r.type == "const") {
            return "consts[" + r.id + "]";
        } else if (r.type == "number") {
            return r.value;
        } else {
            throw new Error("Invalid Ref: " +r.type);
        }
    }
-%>
<% var tmpNameId = 0;                                                                   -%>
<% for(let i=0; i<code.length; i++) {                                 -%>
<%      let inst = code[i];                                           -%>
<%      let signalName;                                           -%>
<%      if (inst.dest.type == "tmp") {                                                  -%>
<%          if (inst.dest.dim == 1) {                                                   -%>
<%              signalName = `signal ${ref(inst.dest)}`                                                -%>
<%          } else if (inst.dest.dim == 3)  {                                           -%>
<%              signalName = `signal ${ref(inst.dest)}[3]`                                                -%>
<%          } else throw new Error("Invalid dimension");                                -%>
<%      }                                                                               -%>
<%      if (inst.op == "add") {                                                         -%>
<%          if ((inst.src[0].dim==1) && (inst.src[1].dim==1)) {                         -%>
    <%- signalName %> <== <%- ref(inst.src[0]) %> + <%- ref(inst.src[1]) %>;
<%          } else if ((inst.src[0].dim==1) && (inst.src[1].dim==3)) {                  -%>
    <%- signalName %> <== [<%- ref(inst.src[0]) %> + <%- ref(inst.src[1]) %>[0], <%- ref(inst.src[1]) %>[1],<%- ref(inst.src[1]) %>[2]] ;
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==1)) {                  -%>
    <%- signalName %> <== [<%- ref(inst.src[0]) %>[0] + <%- ref(inst.src[1]) %>, <%- ref(inst.src[0]) %>[1], <%- ref(inst.src[0]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==3)) {                  -%>
    <%- signalName %> <== [<%- ref(inst.src[0]) %>[0] + <%- ref(inst.src[1]) %>[0], <%- ref(inst.src[0]) %>[1] + <%- ref(inst.src[1]) %>[1], <%- ref(inst.src[0]) %>[2] + <%- ref(inst.src[1]) %>[2]];
<%          } else throw new Error("Invalid src dimensions");                          -%>
<%      } else if (inst.op == "sub") {                                                  -%>
<%          if ((inst.src[0].dim==1) && (inst.src[1].dim==1)) {                         -%>
    <%- signalName %> <== <%- ref(inst.src[0]) %> - <%- ref(inst.src[1]) %>;
<%          } else if ((inst.src[0].dim==1) && (inst.src[1].dim==3)) {                  -%>
    <%- signalName %> <== [<%- ref(inst.src[0]) %> - <%- ref(inst.src[1]) %>[0], -<%- ref(inst.src[1]) %>[1], -<%- ref(inst.src[1]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==1)) {                  -%>
    <%- signalName %> <== [<%- ref(inst.src[0]) %>[0] - <%- ref(inst.src[1]) %>,  <%- ref(inst.src[0]) %>[1], <%- ref(inst.src[0]) %>[2]];
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==3)) {                  -%>
    <%- signalName %> <== [<%- ref(inst.src[0]) %>[0] - <%- ref(inst.src[1]) %>[0],  <%- ref(inst.src[0]) %>[1] - <%- ref(inst.src[1]) %>[1],<%- ref(inst.src[0]) %>[2] - <%- ref(inst.src[1]) %>[2]];
<%          } else throw new Error("Invalid src dimensions");                          -%>
<%      } else if (inst.op == "mul") {                                                  -%>
<%          if ((inst.src[0].dim==1) && (inst.src[1].dim==1)) {                         -%>
    <%- signalName %> <== GLMul1()(<%- ref(inst.src[0]) %>, <%- ref(inst.src[1]) %>);
<%          } else if ((inst.src[0].dim==1) && (inst.src[1].dim==3)) {                  -%>
    <%- signalName %> <== GLCMul()([<%- ref(inst.src[0]) %>, 0, 0], <%- ref(inst.src[1]) %>);
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==1)) {                  -%>
    <%- signalName %> <== GLCMul()(<%- ref(inst.src[0]) %>,[<%- ref(inst.src[1]) %>, 0, 0]);
<%          } else if ((inst.src[0].dim==3) && (inst.src[1].dim==3)) {                  -%>
    <%- signalName %> <== GLCMul()(<%- ref(inst.src[0]) %>,<%- ref(inst.src[1]) %>);
<%          } else throw new Error("Invalid src dimensions");                          -%>
<%      } else if (inst.op == "copy") {                                                 -%>
<%          if (inst.src[0].dim==1 || inst.src[0].dim==3) {                                                   -%>
    <%- signalName %> <== <%- ref(inst.src[0]) %>;
<%          } else throw new Error("Invalid src dimensions");                          -%>
<%      } else if (inst.op == "muladd") {                                                   -%>
<%              if ((inst.src[0].dim==1) && (inst.src[1].dim==1)) {                         -%>
<%                  if (inst.src[2].dim==1) {                                                -%>
    <%- signalName %> <== GLMulAdd()(<%- ref(inst.src[0]) %>, <%- ref(inst.src[1]) %>, <%- ref(inst.src[2]) %>);
<%                  } else {                                                                 -%>
    <%- signalName %> <== [GLMulAdd()(<%- ref(inst.src[0]) %>, <%- ref(inst.src[1]) %>, <%- ref(inst.src[2]) %>[0], <%- ref(inst.src[2]) %>[1], <%- ref(inst.src[2]) %>[2]);
<%                  }                                                                        -%>
<%              } else if(inst.src[0].dim==1 && inst.src[1].dim== 3) {   -%>
<%                  if (inst.src[2].dim==1) {                                                -%>
    <%- signalName %> <== GLCMulAdd()([<%- ref(inst.src[0]) %>, 0, 0], <%- ref(inst.src[1]) %>, [<%- ref(inst.src[2]) %>, 0, 0]);
<%                  } else {                                                                 -%>
    <%- signalName %> <== GLCMulAdd()([<%- ref(inst.src[0]) %>, 0, 0], <%- ref(inst.src[1]) %>, <%- ref(inst.src[2]) %>);
<%                  }                                                                        -%>
<%              } else if(inst.src[0].dim==3 && inst.src[1].dim== 1) {   -%>
<%                  if (inst.src[2].dim==1) {                                                -%>
    <%- signalName %> <== GLCMulAdd()(<%- ref(inst.src[0]) %>, [<%- ref(inst.src[1]) %>, 0, 0], [<%- ref(inst.src[2]) %>, 0, 0]);
<%                  } else {                                                                 -%>
    <%- signalName %> <== GLCMulAdd()(<%- ref(inst.src[0]) %>, [<%- ref(inst.src[1]) %>, 0, 0], <%- ref(inst.src[2]) %>);
<%                  }                                                                        -%>
<%              } else if(inst.src[0].dim==3 && inst.src[1].dim== 3) {   -%>
<%                  if (inst.src[2].dim==1) {                                                -%>
    <%- signalName %> <== GLCMulAdd()(<%- ref(inst.src[0]) %>, <%- ref(inst.src[1]) %>, [<%- ref(inst.src[2]) %>, 0, 0]);     
<%                  } else {                                                                 -%>
    <%- signalName %> <== GLCMulAdd()(<%- ref(inst.src[0]) %>, <%- ref(inst.src[1]) %>, <%- ref(inst.src[2]) %>);
<%                  }                                                                        -%>
<%              } else throw new Error("Invalid src dimensions");                           -%>
<%      } else throw new Error("Invalid op");                                           -%>
<% }                                                                                    -%>
<% return ref(code[code.length-1].dest);                                                -%>
<% }                                                                                    -%>

template parallel VerifyFRI(nBitsExt, prevStepBits, currStepBits, nextStepBits, e0, e1) {
    var nextStep = currStepBits - nextStepBits;
    var step = prevStepBits - currStepBits;

    var p = 0xFFFFFFFF00000001;

    signal input ys[<%- starkStruct.steps[0].nBits %>];
    signal input s_specialX[3];
    signal input s_vals_p1[2**step][3];
    signal input s_vals_p2[2**nextStep][3];
    signal input enable;

    signal s_sx[currStepBits];
    s_sx[0] <== GLMul()(ys[0] * (e1 - e0) + e0, ys[1] * (_inv1(roots(prevStepBits - 1)) -1) + 1);
    for (var i=1; i< currStepBits; i++ ) {
        s_sx[i] <== GLMul()(s_sx[i-1], ys[i + 1] * (_inv1(roots(prevStepBits - (i + 1))) -1) + 1);
    }

    signal s_X; 
    if(currStepBits > 1) {
        s_X <== s_sx[currStepBits - 2];
    } else {
        s_X <== GLMul()(e0, ys[0] * (_inv1(roots(prevStepBits)) -1) + 1);
    }

    signal evalPol[3] <== EvalPol(2**step)(FFT(step, 1)(s_vals_p1), GLCMul()(s_specialX, [s_X, 0, 0]));
    
    var s_keys_lowValues[nextStep];
    for(var i = 0; i < nextStep; i++) {
        s_keys_lowValues[i] = ys[i + nextStepBits];
    } 
   
    signal lowValues[3] <== TreeSelector(nextStep, 3)(s_vals_p2, s_keys_lowValues);
    signal cNorm[3] <== GLCNorm()([evalPol[0] - lowValues[0] + p, evalPol[1] - lowValues[1] + p, evalPol[2] - lowValues[2] + p]);
    
    enable * cNorm[0] === 0;
    enable * cNorm[1] === 0;
    enable * cNorm[2] === 0;
}

template VerifyEvaluations() {
    signal input challenges[8][3];
    signal input evals[<%- starkInfo.evMap.length %>][3];
    signal input publics[<%- pil.publics.length %>];
    signal input enable;

    var p = 0xFFFFFFFF00000001;

    var zMul[<%- starkStruct.nBits %>][3];
    for (var i=0; i< <%- starkStruct.nBits %> ; i++) {
        if (i==0) {
            zMul[i] = GLCMul()(challenges[7], challenges[7]);
        } else {
            zMul[i] = GLCMul()(zMul[i-1], zMul[i-1]);
        }
    }

    signal Z[3] <== [zMul[<%- starkStruct.nBits -1%>][0] -1 + p, zMul[<%- starkStruct.nBits -1%>][1], zMul[<%- starkStruct.nBits -1%>][2]];

<% const evalP = unrollCode(starkInfo.verifierCode.first) -%>


    signal xN[3] <== zMul[<%- starkStruct.nBits -1%>];

    signal xAcc[<%- starkInfo.qDeg %>][3];
    signal qStep[<%- starkInfo.qDeg-1 %>][3];
    signal qAcc[<%- starkInfo.qDeg %>][3];
    for (var i=0; i< <%- starkInfo.qDeg %>; i++) {
        if (i==0) {
            xAcc[0] <== [1, 0, 0];
            qAcc[0] <== evals[<%- starkInfo.evIdx.cm[0][starkInfo.qs[0]] %>+i];
        } else {
            xAcc[i] <== GLCMul()(xAcc[i-1], xN);
            qStep[i-1] <== GLCMul()(xAcc[i], evals[<%- starkInfo.evIdx.cm[0][starkInfo.qs[0]] %>+i]);

            qAcc[i][0] <== qAcc[i-1][0] + qStep[i-1][0];
            qAcc[i][1] <== qAcc[i-1][1] + qStep[i-1][1];
            qAcc[i][2] <== qAcc[i-1][2] + qStep[i-1][2];
        }
    }

    signal qZ[3] <== GLCMul()(qAcc[<%- starkInfo.qDeg-1 %>], Z);


// Final Verification
    var normC[3] = GLCNorm()([<%- evalP %>[0] - qZ[0], <%- evalP %>[1] - qZ[1],<%- evalP %>[2] - qZ[2]]);

    enable * normC[0] === 0;
    enable * normC[1] === 0;
    enable * normC[2] === 0;

}

template parallel VerifyQuery(currStepBits, nextStepBits) {
    var nextStep = currStepBits - nextStepBits;
    signal input ys[<%- starkStruct.steps[0].nBits %>];
    signal input challenges[8][3];
    signal input evals[<%- starkInfo.evMap.length %>][3];
    signal input tree1[<%- starkInfo.mapSectionsN.cm1_2ns %>];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input tree2[<%- starkInfo.mapSectionsN.cm2_2ns %>];
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { %>
    signal input tree3[<%- starkInfo.mapSectionsN.cm3_2ns %>];
<% }                                         -%>
    signal input tree4[<%- starkInfo.mapSectionsN.cm4_2ns %>];
    signal input consts[<%- starkInfo.nConstants %>];
    signal input s0_vals[2**nextStep][3];
    signal input enable;

    ///////////
    // Mapping
    ///////////
    component mapValues = MapValues();
    mapValues.vals1 <== tree1;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    mapValues.vals2 <== tree2;
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    mapValues.vals3 <== tree3;
<% }                                         -%>
    mapValues.vals4 <== tree4;

    var p = 0xFFFFFFFF00000001;

    component xacc[<%- starkStruct.steps[0].nBits %>-1];
    for (var i=1; i<<%- starkStruct.steps[0].nBits %>; i++ ) {
        xacc[i-1] = GLMul();
        if (i==1) {
            xacc[i-1].ina <== ys[0]*(<%- F.shift %> * roots(<%- starkStruct.steps[0].nBits %>)-<%- F.shift %>) + <%- F.shift %>;
        } else {
            xacc[i-1].ina <== xacc[i-2].out;
        }
        xacc[i-1].inb <== ys[i]*(roots(<%- starkStruct.steps[0].nBits %> - i) - 1) +1;
    }

<% if (starkStruct.steps[0].nBits>1) {  -%>
    signal X <== xacc[<%- starkStruct.steps[0].nBits -2 %>].out;
<% } else {                             -%>
    signal X <== ys[0]*(<%- F.shift %> * roots(<%- starkStruct.steps[0].nBits %>)-<%- F.shift %>) + <%- F.shift %>;
<% }                                    -%>


    var den1inv[3] = GLCInv()([X - challenges[7][0] + p, -challenges[7][1] + p, -challenges[7][2] + p]);
    var xDivXSubXi[3] = GLCMul()([X, 0, 0], den1inv);
    
    var wXi[3] = GLCMul()([roots(<%- starkStruct.nBits %>), 0, 0], challenges[7]);
    var den2inv[3] = GLCInv()([X - wXi[0] + p, -wXi[1] + p, -wXi[2] + p]);
    var xDivXSubWXi[3] = GLCMul()([X, 0, 0], den2inv);
   
    <% const evalQ = unrollCode(starkInfo.verifierQueryCode.first) -%>

    // Final Normalization
    signal queryVals[3] <== GLCNorm()(<%- evalQ %>);

    var s0_keys_lowValues[nextStep];
    for(var i = 0; i < nextStep; i++) {
        s0_keys_lowValues[i] = ys[i + nextStepBits];
    } 
   
    signal lowValues[3] <== TreeSelector(nextStep, 3)(s0_vals, s0_keys_lowValues);


    enable * (lowValues[0] - queryVals[0]) === 0;
    enable * (lowValues[1] - queryVals[1]) === 0;
    enable * (lowValues[2] - queryVals[2]) === 0;
}


template MapValues() {
    signal input vals1[<%- starkInfo.mapSectionsN.cm1_2ns %>];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input vals2[<%- starkInfo.mapSectionsN.cm2_2ns %>];
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input vals3[<%- starkInfo.mapSectionsN.cm3_2ns %>];
<% }                                         -%>
    signal input vals4[<%- starkInfo.mapSectionsN.cm4_2ns  %>];

<% const sNames = [null, "cm1_2ns", "cm2_2ns", "cm3_2ns", "cm4_2ns"];              -%>
<% for (let t = 1; t<=4; t++) {                                                  -%>
<%      for (let i=0; i< starkInfo.mapSections[sNames[t]].length; i++) {        -%>
<%          const p = starkInfo.varPolMap[starkInfo.mapSections[sNames[t]][i]];  -%>
<%          if (p.dim == 1) {                                                    -%>
    signal output tree<%- t %>_<%- i %>;
<%          } else if (p.dim == 3) {                                             -%>
    signal output tree<%- t %>_<%- i %>[3];
<%          } else throw new Error("Invalid dim")                                -%>
<%      }                                                                        -%>
<% }                                                                             -%>

<% for (let t = 1; t<=4; t++) {                                                   -%>
<%      for (let i=0; i< starkInfo.mapSections[sNames[t]].length; i++) {        -%>
<%          const p = starkInfo.varPolMap[starkInfo.mapSections[sNames[t]][i]];  -%>
<%          if (p.dim == 1) {                                                    -%>
    tree<%- t %>_<%- i %> <== vals<%- t %>[<%- p.sectionPos %>];
<%          } else if (p.dim == 3) {                                             -%>
    tree<%- t %>_<%- i %> <== [vals<%- t %>[<%- p.sectionPos %>],vals<%- t %>[<%- p.sectionPos + 1 %>] , vals<%- t %>[<%- p.sectionPos + 2 %>]];
<%          } else throw new Error("Invalid dim")                                -%>
<%      }                                                                        -%>
<% }                                                                             -%>
}


template StarkVerifier() {
    signal input publics[<%- pil.publics.length %>];
    signal input root1;
    signal input root2;
    signal input root3;
    signal input root4;

<% if (options.verkeyInput) {  -%>
    signal input rootC;
<% } else { -%>
    signal rootC <== <%- constRoot %>;
<% } -%>

    signal input evals[<%- starkInfo.evMap.length %>][3];

    signal input s0_vals1[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm1_2ns %>];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { %>
    signal input s0_vals2[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm2_2ns %>];
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_vals3[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm3_2ns %>];
<% }                                         -%>
    signal input s0_vals4[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm4_2ns %>];
    signal input s0_valsC[<%- starkStruct.nQueries %>][<%- starkInfo.nConstants%>];
    signal input s0_siblings1[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input s0_siblings2[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_siblings3[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
<% }                                         -%>
    signal input s0_siblings4[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
    signal input s0_siblingsC[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];

<% for (let s=0; s<starkStruct.steps.length-1; s++) {   -%>
    signal input s<%- s+1 %>_root;
<% }                                                     -%>

<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_vals[<%- starkStruct.nQueries %>][<%- (1 << (starkStruct.steps[s-1].nBits - starkStruct.steps[s].nBits))*3 %>];
    signal input s<%- s %>_siblings[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[s].nBits -1) /4) +1 %>][16];
<% }                                                  -%>

    signal input finalPol[<%- 1 << starkStruct.steps[starkStruct.steps.length-1].nBits %>][3];

<% if (options.enableInput) { -%>
    signal input enable;
    enable * (enable -1 ) === 0;
<% } else { -%>
    signal enable;
    enable <== 1;
<% } -%>

    signal challenges[8][3];
<% for (let s=0; s<starkStruct.steps.length; s++) {   -%>
    signal s<%- s %>_specialX[3];
<% }                                                    -%>

    signal ys[<%- starkStruct.nQueries %>][<%- starkStruct.steps[0].nBits %>];

    var p = 0xFFFFFFFF00000001;

    ///////////
    // challenge calculation
    ///////////

<%
const transcript = new Transcript();
transcript.put("publics", pil.publics.length);
transcript.put("root1");
transcript.getField("challenges[0]", 3);
transcript.getField("challenges[1]", 3);
transcript.put("root2");
transcript.getField("challenges[2]", 3);
transcript.getField("challenges[3]", 3);
transcript.put("root3");
transcript.getField("challenges[4]", 3);
transcript.put("root4");
transcript.getField("challenges[7]", 3);
for (let i=0; i<starkInfo.evMap.length; i++) {
    transcript.put(`evals[${i}]`, 3);
}
transcript.getField("challenges[5]", 3);
transcript.getField("challenges[6]", 3);
for (let si=0; si<starkStruct.steps.length; si++) {
    transcript.getField(`s${si}_specialX`, 3);
    if (si < starkStruct.steps.length-1) {
        transcript.put(`s${si+1}_root`);
    } else {
        for (let j=0; j< 1<<starkStruct.steps[starkStruct.steps.length-1].nBits; j++ ) {
            transcript.put(`finalPol[${j}]`, 3);
        }
    }
}
transcript.getPermutations("ys", starkStruct.nQueries, starkStruct.steps[0].nBits);

-%>

<%- transcript.getCode() %>

    ///////////
    // Constrain polynomial check in evaluations
    ///////////

    VerifyEvaluations()(challenges, evals, publics, enable);

    ///////////
    // Step0 Check and evaluate queries
    ///////////

    // Preprocess the s_i vals given as inputs so that we can use anonymous components.
    // Two different processings are done:
    // For s0_vals, the arrays are transposed so that they fit MerkleHash template
    // For (s_i)_vals, the values are passed all together in a single array of length nVals*3. We convert them to vals[nVals][3]
    
    var s0_vals1_p[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm1_2ns %>][1];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    var s0_vals2_p[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm2_2ns %>][1];
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    var s0_vals3_p[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm3_2ns %>][1];
<% } -%>
    var s0_vals4_p[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm4_2ns %>][1];
    var s0_valsC_p[<%- starkStruct.nQueries %>][<%- starkInfo.nConstants %>][1];
<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
    var s<%- s %>_vals_p[<%- starkStruct.nQueries %>][<%- (1 << (starkStruct.steps[s-1].nBits - starkStruct.steps[s].nBits)) %>][3]; 
<% } -%>

    for (var q=0; q<<%- starkStruct.nQueries %>; q++) {
        for (var i = 0; i < <%- starkInfo.mapSectionsN.cm1_2ns %>; i++) {
            s0_vals1_p[q][i][0] = s0_vals1[q][i];
        }
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
        for (var i = 0; i < <%- starkInfo.mapSectionsN.cm2_2ns %>; i++) {
            s0_vals2_p[q][i][0] = s0_vals2[q][i];
        }
<% } -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
        for (var i = 0; i < <%- starkInfo.mapSectionsN.cm3_2ns %>; i++) {
            s0_vals3_p[q][i][0] = s0_vals3[q][i];
        }
<% } -%>
        for (var i = 0; i < <%- starkInfo.mapSectionsN.cm4_2ns %>; i++) {
            s0_vals4_p[q][i][0] = s0_vals4[q][i];
        }
        for (var i = 0; i < <%- starkInfo.nConstants %>; i++) {
            s0_valsC_p[q][i][0] = s0_valsC[q][i];
        }
<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
        for(var c=0; c < <%- (1 << (starkStruct.steps[s-1].nBits - starkStruct.steps[s].nBits))%>; c++) {
            for(var e=0; e < 3; e++) {
                s<%- s %>_vals_p[q][c][e] = s<%- s %>_vals[q][c*3+e];
            }
        }
<% } -%>
    }
    
    var s0_merkle1[q];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    var s0_merkle2[q]; 
<% }                                        -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    var s0_merkle3[q];
<% }     -%>
    var s0_merkle4[q];
    var s0_merkleC[q];
<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
    var s<%- s %>_merkle[q];
<% } -%>

    //Check that all that the root obtained using the values and the sibling path is the same as the one being sent as input 
    for (var q=0; q<<%- starkStruct.nQueries %>; q++) {
        
        //Calculate merkle root for s0 vals
        s0_merkle1[q] = MerkleHash(1, <%- starkInfo.mapSectionsN.cm1_2ns %>, <%- 1 << starkStruct.steps[0].nBits %>)(s0_vals1_p[q], s0_siblings1[q], ys[q]);
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
        s0_merkle2[q] = MerkleHash(1, <%- starkInfo.mapSectionsN.cm2_2ns %>, <%- 1 << starkStruct.steps[0].nBits %>)(s0_vals2_p[q], s0_siblings2[q], ys[q]);
<% }                                        -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
        s0_merkle3[q] = MerkleHash(1, <%- starkInfo.mapSectionsN.cm3_2ns %>, <%- 1 << starkStruct.steps[0].nBits %>)(s0_vals3_p[q], s0_siblings3[q], ys[q]);
<% }     -%>
        s0_merkle4[q] = MerkleHash(1, <%- starkInfo.mapSectionsN.cm4_2ns %>, <%- 1 << starkStruct.steps[0].nBits %>)(s0_vals4_p[q], s0_siblings4[q], ys[q]);
        s0_merkleC[q] = MerkleHash(1, <%- starkInfo.nConstants %>, <%- 1 << starkStruct.steps[0].nBits %>)(s0_valsC_p[q], s0_siblingsC[q], ys[q]);                                    

<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
<%  let keys_merkle = [];
    for(let i = 0; i < starkStruct.steps[s].nBits; ++i) {
        keys_merkle.push(`ys[q][${i}]`);
    }
-%>
        // Calculate merkle root for s<%- s %> vals
        var s<%- s %>_keys_merkle[<%- starkStruct.steps[s].nBits %>] = [<%- keys_merkle %>];
        s<%- s %>_merkle[q] = MerkleHash(3, <%- 1 << (starkStruct.steps[s-1].nBits - starkStruct.steps[s].nBits) %>, <%- 1 << starkStruct.steps[s].nBits %>)(s<%- s %>_vals_p[q], s<%- s %>_siblings[q], s<%- s %>_keys_merkle);

<% } -%>
    
        // After checking that all merkle roots are properly built, the query and the intermediate 
        // polynomials need to be verified 
<% let nextValsPol = 0 < starkStruct.steps.length-1 ? "s1_vals_p[q]" : "finalPol"; -%>
<% let nextStep = 0 < starkStruct.steps.length-1 ? starkStruct.steps[1].nBits : 0 -%>
        // Verify that the query is properly constructed. This is done by checking that the linear combination of the set of 
        // polynomials committed during the different rounds evaluated at z matches with the commitment of the FRI polynomial (unsure)
<% if (starkInfo.mapSectionsN.cm2_2ns > 0 && starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
        VerifyQuery(<%- starkStruct.steps[0].nBits %>, <%- nextStep %>)(ys[q], challenges, evals, s0_vals1[q], s0_vals2[q],s0_vals3[q],s0_vals4[q],s0_valsC[q], <%- nextValsPol %>, enable);
<% } else if(starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
        VerifyQuery(<%- starkStruct.steps[0].nBits %>, <%- nextStep %>)(ys[q], challenges, evals, s0_vals1[q], s0_vals2[q],s0_vals4[q],s0_valsC[q], <%- nextValsPol %>, enable);
<% } else if(starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
        VerifyQuery(<%- starkStruct.steps[0].nBits %>, <%- nextStep %>)(ys[q], challenges, evals, s0_vals1[q], s0_vals3[q],s0_vals4[q],s0_valsC[q], <%- nextValsPol %>, enable);
<% } else { -%>
        VerifyQuery(<%- starkStruct.steps[0].nBits %>, <%- nextStep %>)(ys[q], challenges, evals, s0_vals1[q],s0_vals4[q],s0_valsC[q], <%- nextValsPol %>, enable);
<% } -%>

        // For each folding level we need to check that the polynomial is properly constructed
        // Remember that if the step between polynomials is b = 2^l, the next polynomial p_(i+1) will have degree deg(p_i) / b
<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
<%
    const e1 = F.inv( F.mul(
        F.exp(F.shift, 1 << (starkStruct.nBitsExt -starkStruct.steps[s-1].nBits) ),
        F.w[starkStruct.steps[s-1].nBits]
    ));
    const e0 = F.inv(F.exp(F.shift, 1 << (starkStruct.nBitsExt -starkStruct.steps[s-1].nBits) ) );
-%>

        // Check S<%- s %> 
<%  if (s < starkStruct.steps.length-1) {            -%>
        VerifyFRI(<%- starkStruct.nBitsExt %>, <%- starkStruct.steps[s-1].nBits %>, <%- starkStruct.steps[s].nBits %>, <%- starkStruct.steps[s+1].nBits %>, <%- e0 %>, <%- e1 %>)(ys[q], s<%- s %>_specialX, s<%- s %>_vals_p[q], s<%- s+1 %>_vals_p[q], enable);
<%  } else { -%>
        VerifyFRI(<%- starkStruct.nBitsExt %>, <%- starkStruct.steps[s-1].nBits %>, <%- starkStruct.steps[s].nBits %>, 0, <%- e0 %>, <%- e1 %>)(ys[q], s<%- s %>_specialX, s<%- s %>_vals_p[q], finalPol, enable);
<% } -%>
<% } -%>
    }

    ///////////
    // Check Merkle Proofs
    ///////////

    for (var q=0; q<<%- starkStruct.nQueries %>; q++) {
        enable * (s0_merkle1[q] - root1) === 0;
        enable * (s0_merkle4[q] - root4) === 0;
        enable * (s0_merkleC[q] - rootC) === 0;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
        enable * (s0_merkle2[q] - root2) === 0;
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
        enable * (s0_merkle3[q] - root3) === 0;
<% }                                         -%>
<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
        enable * (s<%- s %>_merkle[q] - s<%- s %>_root) === 0;
<% }                                         -%>
    }

    ///////
    // Check Degree last pol
    ///////

<% const nLastBits = starkStruct.steps[ starkStruct.steps.length-1].nBits;  -%>
<% console.log("NLastBits", nLastBits); -%>
<% const maxDegBits =  Math.max(nLastBits -  (starkStruct.nBitsExt - starkStruct.nBits), 0); -%>
<% console.log("MaxDegBits", maxDegBits); -%>
    // Calculate the IFFT to get the coefficients of finalPol 
    var lastIFFT[<%- 1 << nLastBits %>][3] = FFT(<%- nLastBits %>, 1)(finalPol);

    // Check that the degree of the final polynomial is bounded by the degree defined in the last step of the folding
    // This means ??? in terms of IFFT
    for (var k= <%- 1 << maxDegBits %>; k< <%- 1 << nLastBits %>; k++ ) {
        for (var e=0; e<3; e++) {
            enable * lastIFFT[k][e] === 0;
        }
    }

}

<% if (!options.skipMain) {  -%>

template Main() {
    signal input proverAddr;
    signal output publicsHash;

    signal input publics[<%- pil.publics.length %>];
    signal input root1;
    signal input root2;
    signal input root3;
    signal input root4;
    signal input evals[<%- starkInfo.evMap.length %>][3];

    signal input s0_vals1[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm1_2ns %>];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input s0_vals2[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm2_2ns %>];
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_vals3[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm3_2ns %>];
<% }                                         -%>
    signal input s0_vals4[<%- starkStruct.nQueries %>][<%- starkInfo.mapSectionsN.cm4_2ns %>];
    signal input s0_valsC[<%- starkStruct.nQueries %>][<%- starkInfo.nConstants%>];
    signal input s0_siblings1[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    signal input s0_siblings2[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    signal input s0_siblings3[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
<% }                                         -%>
    signal input s0_siblings4[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];
    signal input s0_siblingsC[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[0].nBits - 1)/4)+1 %>][16];

<% for (let s=0; s<starkStruct.steps.length-1; s++) {   -%>
    signal input s<%- s+1 %>_root;
<% }                                                     -%>

<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
    signal input s<%- s %>_vals[<%- starkStruct.nQueries %>][<%- (1 << (starkStruct.steps[s-1].nBits - starkStruct.steps[s].nBits))*3 %>];
    signal input s<%- s %>_siblings[<%- starkStruct.nQueries %>][<%- Math.floor((starkStruct.steps[s].nBits -1) /4) +1 %>][16];
<% }                                                  -%>

    signal input finalPol[<%- 1 << starkStruct.steps[starkStruct.steps.length-1].nBits %>][3];


    component sv = StarkVerifier();

    sv.publics <== publics;
    sv.root1 <== root1;
    sv.root2 <== root2;
    sv.root3 <== root3;
    sv.root4 <== root4;
    sv.evals <== evals;


    sv.s0_vals1 <== s0_vals1;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    sv.s0_vals2 <== s0_vals2;
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    sv.s0_vals3 <== s0_vals3;
<% }                                         -%>
    sv.s0_vals4 <== s0_vals4;
    sv.s0_valsC <== s0_valsC;
    sv.s0_siblings1 <== s0_siblings1;
<% if (starkInfo.mapSectionsN.cm2_2ns > 0) { -%>
    sv.s0_siblings2 <== s0_siblings2;
<% }                                         -%>
<% if (starkInfo.mapSectionsN.cm3_2ns > 0) { -%>
    sv.s0_siblings3 <== s0_siblings3;
<% }                                         -%>
    sv.s0_siblings4 <== s0_siblings4;
    sv.s0_siblingsC <== s0_siblingsC;

<% for (let s=0; s<starkStruct.steps.length-1; s++) {   -%>
    sv.s<%- s+1 %>_root <== s<%- s+1 %>_root;
<% }                                                     -%>

<% for (let s=1; s<starkStruct.steps.length; s++) {   -%>
    sv.s<%- s %>_vals <== s<%- s %>_vals;
    sv.s<%- s %>_siblings <== s<%- s %>_siblings;
<% }                                                  -%>
    sv.finalPol <== finalPol;

    //////
    // Calculate Publics Hash
    //////

    var n2bProverAddr[160] = Num2Bits(160)(proverAddr);

    component publicsHasher = Sha256(<%- 160 + 64*pil.publics.length %>);
    for (var i=0; i<160; i++) {
        publicsHasher.in[160 - i - 1] <== n2bProverAddr[i];
    }

    var offset = 160;

    for (var i=0; i<<%- pil.publics.length %>; i++) {
        var n2bPublics[64] = Num2Bits(64)(publics[i]);
        var cmpPublics = CompConstant64(0xFFFFFFFF00000000)(n2bPublics);
        for (var j=0; j<64; j++) {
            publicsHasher.in[offset + 64 - j - 1] <== n2bPublics[j];
        }
        cmpPublics === 0;
        offset += 64;
    }

    component n2bPublicsHash = Bits2Num(256);
    for (var i = 0; i < 256; i++) {
        n2bPublicsHash.in[i] <== publicsHasher.out[255-i];
    }

    publicsHash <== n2bPublicsHash.out;
}

component main = Main();
<% } -%>
