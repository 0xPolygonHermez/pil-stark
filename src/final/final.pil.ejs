//Configuration values
constant %N = 2**<%- nBits %>; // Upper bound for the number of rows to be used across various state machines.

// Global state machine
// It is used to store various polynomials representing small lookup tables 
namespace Global(%N);
    pol constant L1; // Lagrange polynomial for the first public

<% for (let i=6; i<nPublics; i+=6) { -%>
    pol constant L<%- Math.floor(i/6) +1 %>; // Lagrange polynomial for the 12 publics corresponding to the i^th row
<% } -%>
    
<% for (let i=1; i<nPublics; i++) { -%>
    pol constant L<%- i+1 %>; // Lagrange polynomial for the i^th p
<% } -%>

namespace Final(%N);
    pol constant S[6];
    pol constant C[5];
    pol constant PARTIAL;
    pol constant POSEIDON_T;
    pol constant RANGE_CHECK;
    pol constant RANGE;
    pol constant GATE;
    pol commit a[6];

    // Set all the publics. They are stored in the following order -> a[0](0), ....  , a[11](0), a[0](1), .... , a[11](1) ... 
<% for (let i=0; i<nPublics; i++) { -%>
    public pub<%- i%> = a[0](<%- i %>);
<% } -%>

    // Enforces the first element of the j^th row a[0](j) to be equal to the corresponding public input
<% for (let i=0; i<nPublics; i++) { -%>
    Global.L<%- i+1 %> * (a[0] - :pub<%- i %>) = 0;
<% } -%>

    // Normal plonk gates

    // C[0] -> Qm
    // C[1] -> Ql
    // C[2] -> Qr
    // C[3] -> Qo
    // C[4] -> Qc
    
    pol a01 = a[0]*a[1];
    pol g012 = C[0]*a01 + C[1]*a[0] + C[2]*a[1] + C[3]*a[2] + C[4];
    g012*GATE = 0;

    pol a34 = a[3]*a[4];
    pol g345 = C[0]*a34 + C[1]*a[3] + C[2]*a[4] + C[3]*a[5] + C[4];
    g345*GATE = 0;

    // POSEIDON GATE - Check that a BN128 Poseidon round is valid

<% for (let i=0; i<nInPoseidon; i++) { -%>

    // Calculate the 7th power of the <%- i %>th element
    pol a<%- i %>_1 = a[<%- i %>] +  C[<%- i %>];
    pol a<%- i %>_2 = a<%- i %>_1 * a<%- i %>_1;
    pol a<%- i %>_4 = a<%- i %>_2 * a<%- i %>_2;
    pol a<%- i %>_5 = a<%- i %>_4 * a<%- i %>_1;
<%      if (i==0) { -%>
    pol a<%- i %>_R = a<%- i %>_5; // The first element is always exponentiated, no matter the round
<%      } else { -%>
    pol a<%- i %>_R = PARTIAL * (a<%- i %>_1 - a<%- i %>_5) + a<%- i %>_5; // Determine if the <%- i %>th element needs to be raised to the 5th power or not using PARTIAL
<%      } -%>
<% } -%>

    // Check Poseidon rounds that use M matrix
<%  
const poseidonMDS = [];
for(let i = 0; i < nInPoseidon; ++i) { 
    const poseidonRow = [];
    for(let j = 0; j < nInPoseidon; j++) { 
        poseidonRow.push(`${BigInt(M[i][j])} * a${j}_R`); 
    }
    poseidonMDS.push(poseidonRow);
}    -%>

<% for(let i = 0; i < nInPoseidon; ++i) { -%>
    pol poseidon<%- i %>_M = <%- poseidonMDS[i].join(' + ') %>;
<% } -%>

<% for(let i = 0; i < nInPoseidon; ++i) { -%>
    POSEIDON_T * (a[<%- i %>]' - poseidon<%- i %>_M) = 0;
<% } -%>
  
    // Range Check

    pol lc1 = a[2] + 256*a[1];
    pol lc2 = a[3] + 256*lc1;
    pol lc3 = a[4] + 256*lc2;
    pol lc4 = a[5] + 256*lc3;
    pol lc5 = a[1]' + 256*lc4;
    pol lc6 = a[2]' + 256*lc5;
    pol lc7 = a[3]' + 256*lc6;
    pol lc8 = a[4]' + 256*lc7;
    
    pol inpVal = a[5]' + 256*lc8;
    
    RANGE_CHECK * (a[0] - inpVal) = 0;

    RANGE_CHECK { a[1], a[2], a[3], a[4], a[5] } in { RANGE, RANGE, RANGE, RANGE, RANGE };

    
    // Connection equations
<% 
    let a = [];
    let S = [];
    for(let i = 0; i < 6; ++i) {
        a.push(`a[${i}]`);
        S.push(`S[${i}]`);
    }
-%>
    { <%- a.join(',') %> } connect { <%- S.join(',')  %> }


        